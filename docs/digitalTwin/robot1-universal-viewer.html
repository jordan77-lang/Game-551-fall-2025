<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Robot1 Universal Viewer (AR/VR/3D)</title>
  <style>
    html,body { margin:0; height:100%; background:#ddd; color:#111; font-family:sans-serif; }
    body { overflow:hidden; }
    #mode-select { position:fixed; top:20px; left:50%; transform:translateX(-50%); z-index:10; background:#222; border-radius:8px; padding:12px 24px; box-shadow:0 2px 8px #0008; }
    #mode-select button { margin:0 8px; padding:8px 18px; border-radius:6px; border:0; background:#0a84ff; color:#fff; font-weight:600; cursor:pointer; font-size:1em; }
    #mode-select button.active { background:#fff; color:#0a84ff; }
    #msg { position:fixed; left:50%; top:12px; transform:translateX(-50%); background:#222; color:#fff; padding:6px 12px; border-radius:6px; z-index:20; }
    #fatal-error { position:fixed; left:0; right:0; bottom:0; background:#c00; color:#fff; padding:8px 10px; display:none; z-index:30; }
  </style>
</head>
<body>
  <div id="mode-select">
    <button id="btn-3d" class="active">3D View</button>
    <button id="btn-ar">AR</button>
    <button id="btn-vr">VR</button>
  </div>
  <div id="msg" role="status" aria-live="polite">Booting…</div>
  <div id="fatal-error" aria-hidden="true"></div>
  <script type="module">
    import * as THREE from './lib/three.module.js';
    import { GLTFLoader } from './lib/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from './lib/examples/jsm/controls/OrbitControls.js';
    import { VRButton } from './lib/examples/jsm/webxr/VRButton.js';
    // ARButton is not standard, so AR will use WebXR immersive-ar if available

    const msg = document.getElementById('msg');
    const fatal = document.getElementById('fatal-error');
    const say = (t)=>{ msg.textContent = t; };
    const showFatal = (t)=>{ fatal.textContent = t; fatal.style.display='block'; };

    // Mode buttons
    const btn3d = document.getElementById('btn-3d');
    const btnAR = document.getElementById('btn-ar');
    const btnVR = document.getElementById('btn-vr');
    let currentMode = '3d';

    // Scene setup
    let renderer, scene, camera, controls, model, vrButton, arSession, arPlaced = false;
    let reticle, hitTestSource, refSpace, viewerSpace;
    // VR sound effect
    let robotSound, listener;

    function clearScene() {
      if (renderer && renderer.domElement.parentNode) renderer.domElement.parentNode.removeChild(renderer.domElement);
      if (vrButton && vrButton.parentNode) vrButton.parentNode.removeChild(vrButton);
      if (arSession) { arSession.end(); arSession = null; }
      msg.textContent = 'Booting…';
      fatal.style.display = 'none';
      arPlaced = false;
    }

    function setupRenderer() {
      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.3;
      renderer.physicallyCorrectLights = true;
      renderer.setClearAlpha(0);
      document.body.appendChild(renderer.domElement);
    }

    function setupScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xdddddd); // Light grey background
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 1000);
      camera.position.set(0, 1.2, 2.5);
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1, 0);
      controls.update();
      // Lighting (brighter)
      const hemi = new THREE.HemisphereLight(0xffffff, 0x8888aa, 1.5);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 5.0);
      dir.position.set(3, 10, 10);
      scene.add(dir);
      const amb = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(amb);
    }

    function loadModel(path, onLoaded) {
      const loader = new GLTFLoader();
      loader.load(path, gltf => {
        model = gltf.scene;
        model.traverse((n)=>{ if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
        scene.add(model);
        if (onLoaded) onLoaded();
        say('Model loaded');
      }, undefined, err => {
        console.error(err);
        showFatal('Failed to load ' + path + ' — ' + (err.message||err));
        say('Model load failed');
      });
    }

    function animate() {
      if (currentMode === 'vr') {
        renderer.setAnimationLoop(() => {
          controls.update();
          renderer.render(scene, camera);
        });
      } else {
        function loop() {
          requestAnimationFrame(loop);
          controls.update();
          renderer.render(scene, camera);
        }
        loop();
      }
    }

    // 3D View
    function start3D() {
      clearScene();
      setupRenderer();
      setupScene();
      loadModel('./Robot1.glb');
      animate();
    }

    // VR Mode
    function startVR() {
      clearScene();
      setupRenderer();
      setupScene();
      camera.position.set(0, 1.6, 3.5);
      // Set up audio listener and sound
      listener = new THREE.AudioListener();
      camera.add(listener);
      robotSound = new THREE.Audio(listener);
      let robotSoundLoaded = false;
      const audioLoader = new THREE.AudioLoader();
      audioLoader.load('./robot.mp3', function(buffer) {
        robotSound.setBuffer(buffer);
        robotSound.setLoop(false);
        robotSound.setVolume(0.8);
        robotSoundLoaded = true;
      });
      // Set 360 background for VR
      let skyLoaded = false;
      const loader = new THREE.TextureLoader();
      loader.load('./sky.jpeg', function(texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.background = texture;
        skyLoaded = true;
      });
      // Load model and move it a bit further away in Z
      loadModel('./Robot1.glb', () => {
        if (model) {
          model.position.set(0, 0, -1.5); // Place model 1.5 units in front of camera
        }
        renderer.xr.enabled = true;
        vrButton = VRButton.createButton(renderer);
        document.body.appendChild(vrButton);

        // --- Unified VR animation loop: controller and hand tracking sound, 360 background ---
        const raycaster = new THREE.Raycaster();
        // Controller select event
        function onSelect() {
          if (!model) return;
          const meshes = [];
          model.traverse(obj => { if (obj.isMesh) meshes.push(obj); });
          for (let i = 0; i < 2; i++) {
            const controller = renderer.xr.getController(i);
            if (!controller) continue;
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            const intersects = raycaster.intersectObjects(meshes, true);
            if (intersects.length > 0) {
              if (robotSound && robotSound.buffer) {
                if (robotSound.context && robotSound.context.state === 'suspended') {
                  robotSound.context.resume();
                }
                robotSound.stop();
                robotSound.play();
              }
              break;
            }
          }
        }
        for (let i = 0; i < 2; i++) {
          const controller = renderer.xr.getController(i);
          if (controller) {
            controller.addEventListener('select', onSelect);
          }
        }

        renderer.setAnimationLoop((time, frame) => {
          controls.update();
          renderer.render(scene, camera);
          // Hand tracking pinch-to-sound
          const session = renderer.xr.getSession();
          if (!session || !model) return;
          const meshes = [];
          model.traverse(obj => { if (obj.isMesh) meshes.push(obj); });
          for (const inputSource of session.inputSources) {
            if (inputSource.hand) {
              let thumbTip, indexTip;
              try {
                thumbTip = inputSource.hand.get('thumb-tip');
                indexTip = inputSource.hand.get('index-finger-tip');
              } catch (e) {
                thumbTip = null; indexTip = null;
              }
              if (
                thumbTip && indexTip &&
                thumbTip.transform && indexTip.transform &&
                thumbTip.transform.position && indexTip.transform.position &&
                typeof thumbTip.transform.position.x === 'number' &&
                typeof thumbTip.transform.position.y === 'number' &&
                typeof thumbTip.transform.position.z === 'number' &&
                typeof indexTip.transform.position.x === 'number' &&
                typeof indexTip.transform.position.y === 'number' &&
                typeof indexTip.transform.position.z === 'number'
              ) {
                const thumbPos = new THREE.Vector3().set(
                  thumbTip.transform.position.x,
                  thumbTip.transform.position.y,
                  thumbTip.transform.position.z
                );
                const indexPos = new THREE.Vector3().set(
                  indexTip.transform.position.x,
                  indexTip.transform.position.y,
                  indexTip.transform.position.z
                );
                const pinchDist = thumbPos.distanceTo(indexPos);
                if (pinchDist < 0.025) {
                  // Raycast from index tip forward
                  const direction = new THREE.Vector3(0, 0, -1);
                  if (
                    indexTip.transform.orientation &&
                    typeof indexTip.transform.orientation.x === 'number' &&
                    typeof indexTip.transform.orientation.y === 'number' &&
                    typeof indexTip.transform.orientation.z === 'number' &&
                    typeof indexTip.transform.orientation.w === 'number'
                  ) {
                    const quat = new THREE.Quaternion(
                      indexTip.transform.orientation.x,
                      indexTip.transform.orientation.y,
                      indexTip.transform.orientation.z,
                      indexTip.transform.orientation.w
                    );
                    direction.applyQuaternion(quat);
                  }
                  raycaster.ray.origin.copy(indexPos);
                  raycaster.ray.direction.copy(direction);
                  const intersects = raycaster.intersectObjects(meshes, true);
                  if (intersects.length > 0) {
                    if (robotSound && robotSound.buffer && !robotSound.isPlaying) {
                      if (robotSound.context && robotSound.context.state === 'suspended') {
                        robotSound.context.resume();
                      }
                      robotSound.stop();
                      robotSound.play();
                    }
                  }
                }
              }
            }
          }
        });
      });
// removed stray closing brace

    }

    // AR Mode (WebXR immersive-ar)
    async function startAR() {
      clearScene();
      setupRenderer();
      setupScene();
      loadModel('./Robot1.glb', () => {
        say('Initializing AR…');
      });
      if (!('xr' in navigator)) {
        showFatal('WebXR not supported on this device/browser.');
        return;
      }
      try {
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (!supported) {
          showFatal('AR not supported on this device/browser.');
          return;
        }
        arSession = await navigator.xr.requestSession('immersive-ar', { requiredFeatures:['hit-test'], optionalFeatures:['dom-overlay'], domOverlay:{ root: document.body } });
      } catch (e) {
        showFatal('Failed to start AR session: ' + e.message);
        return;
      }
      renderer.xr.enabled = true;
      renderer.xr.setReferenceSpaceType('local');
      await renderer.xr.setSession(arSession);
      // Reticle
      reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.12,0.14,48,1),
        new THREE.MeshBasicMaterial({ color:0x00ff88, toneMapped:false })
      );
      reticle.rotation.x = -Math.PI/2;
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);
      // Hit test
      refSpace = renderer.xr.getReferenceSpace();
      viewerSpace = await arSession.requestReferenceSpace('viewer');
      hitTestSource = await arSession.requestHitTestSource({ space: viewerSpace });
      // AR frame loop
      renderer.setAnimationLoop((time, frame) => {
        const xrCam = renderer.xr.getCamera();
        // Hit test
        if (hitTestSource && refSpace && model) {
          const hits = frame.getHitTestResults(hitTestSource);
          if (hits.length) {
            const hit = hits[0];
            const pose = hit.getPose(refSpace);
            if (pose) {
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
              if (!arPlaced && frame.session.inputSources.length) {
                frame.session.inputSources[0].gamepad && frame.session.inputSources[0].gamepad.buttons[0].pressed && placeModel();
              }
            }
          } else {
            reticle.visible = false;
          }
        }
        renderer.render(scene, xrCam);
      });
      // Place model on tap
      function placeModel() {
        if (arPlaced) return;
        if (!model) return;
        model.position.setFromMatrixPosition(reticle.matrix);
        arPlaced = true;
        say('Placed!');
      }
      window.addEventListener('touchend', placeModel);
      arSession.addEventListener('end', () => {
        window.removeEventListener('touchend', placeModel);
      });
    }

    // Button handlers
    btn3d.onclick = () => { currentMode = '3d'; btn3d.classList.add('active'); btnAR.classList.remove('active'); btnVR.classList.remove('active'); start3D(); };
    btnAR.onclick = () => { currentMode = 'ar'; btnAR.classList.add('active'); btn3d.classList.remove('active'); btnVR.classList.remove('active'); startAR(); };
    btnVR.onclick = () => { currentMode = 'vr'; btnVR.classList.add('active'); btn3d.classList.remove('active'); btnAR.classList.remove('active'); startVR(); };

    // Start in 3D mode
    start3D();

    // Responsive resize
    window.addEventListener('resize', () => {
      if (renderer) {
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (camera) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
        }
      }
    });
  </script>
</body>
</html>
