<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Digital Twin — iOS Viewer</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22/>">
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    #msg{position:fixed;left:50%;top:12px;transform:translateX(-50%);background:#222;color:#fff;padding:6px 12px;border-radius:6px;z-index:10}
    #hint{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);background:#fff3;color:#111;padding:8px 14px;border-radius:6px;z-index:10}
    #arButtonWrap{position:fixed;right:12px;top:12px;z-index:10}
    #reset{position:fixed;right:12px;bottom:12px;z-index:10}
    button{font:600 14px/1 system-ui;padding:.5rem .7rem;border-radius:.6rem;border:0;cursor:pointer}
    #ios-instructions{position:fixed;left:50%;top:60px;transform:translateX(-50%);background:#fff3;color:#111;padding:10px 18px;border-radius:8px;z-index:20;max-width:90vw;}
  </style>
</head>
<body>
  <div id="msg" role="status" aria-live="polite">Booting…</div>
  <div id="arButtonWrap" hidden><button id="arBtn">Enter AR</button></div>
  <div id="hint" hidden>Move to find a surface. Tap to place.</div>
  <button id="reset" hidden>Reset</button>
  <div id="ios-instructions">
    <strong>iOS Instructions:</strong><br>
    For best results, open this page in <b>Safari</b> on your iPhone or iPad.<br>
    If you see a camera permission prompt, allow access.<br>
    <br>
    <em>Note:</em> WebXR support on iOS is experimental. If AR does not work, try updating iOS or use desktop mode for 3D viewing.
  </div>
  <script type="importmap">
    { "imports": { "three": "./lib/three.module.js" } }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from './lib/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from './lib/examples/jsm/controls/OrbitControls.js';
    import { RoomEnvironment } from './lib/examples/jsm/environments/RoomEnvironment.js';

    // --- UI helpers ---
    const msg = document.getElementById('msg');
    const say  = (t,p=false)=>{ msg.textContent=t; if(!p) setTimeout(()=>{ if(msg.textContent===t) msg.textContent=''; }, 2500); };
    const hint = document.getElementById('hint');
    const arBtnWrap = document.getElementById('arButtonWrap');
    const arBtn = document.getElementById('arBtn');
    const resetBtn = document.getElementById('reset');

    const onHttps = location.protocol==='https:' || location.hostname==='localhost';
    if (!onHttps) say('Use HTTPS or localhost or the camera will be blocked.', true);

    // Warn for in-app browsers (WebViews like Grok/IG)
    const ua = navigator.userAgent.toLowerCase();
    if (ua.includes('; wv;') || ua.includes('grok') || ua.includes('instagram') || ua.includes('fbav') || ua.includes('tiktok')) {
      say('Open in Chrome or Safari. In-app browsers break WebXR.', true);
    }

    // --- Renderer + scene (desktop defaults) ---
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3;
    renderer.physicallyCorrectLights = true;
    renderer.setClearAlpha(0);
    document.body.appendChild(renderer.domElement);

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const pmrem = new THREE.PMREMGenerator(renderer);
    const envTex = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;
    scene.environment = envTex;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x333355, 1.0);
    const dir  = new THREE.DirectionalLight(0xffffff, 2.2);
    dir.position.set(1,2,1);
    dir.castShadow = true;
    dir.shadow.mapSize.set(512,512);
    dir.shadow.camera.near = 0.01;
    dir.shadow.camera.far  = 10;
    dir.shadow.normalBias  = 0.02;
    const amb  = new THREE.AmbientLight(0xffffff, 0.18);
    scene.add(hemi, dir, amb);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(10,10),
      new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.85 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -0.001;
    ground.receiveShadow = true;
    ground.visible = false;
    scene.add(ground);

    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.12,0.14,48,1),
      new THREE.MeshBasicMaterial({ color:0x00ff88, toneMapped:false })
    );
    reticle.rotation.x = -Math.PI/2;
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    let camera = null, controls = null;
    let srcModel = null;
    new GLTFLoader().load('./sample.glb', gltf=>{
      srcModel = gltf.scene;
      srcModel.traverse(o=>{
        if (o.isMesh){
          o.castShadow = true;
          o.receiveShadow = false;
          if (o.material && 'envMapIntensity' in o.material) o.material.envMapIntensity = 1.2;
        }
      });
      say('Model loaded.');
      if (camera) addDesktopModel();
    }, undefined, err=>{ console.error(err); say('Failed to load ./sample.glb', true); });

    const TARGET_SIZE_M = 0.4;
    function centerBaseAndScale(object, targetMeters){
      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      object.position.x -= center.x;
      object.position.z -= center.z;
      object.position.y -= box.min.y;
      const s = targetMeters / Math.max(size.x, size.y, size.z || 1);
      object.scale.setScalar(s);
      const box2 = new THREE.Box3().setFromObject(object);
      object.position.y -= box2.min.y;
    }

    function addDesktopModel(){
      const root = srcModel.clone(true);
      centerBaseAndScale(root, TARGET_SIZE_M);
      scene.add(root);
      ground.visible = true;
      const nd = TARGET_SIZE_M;
      const dist = nd*0.6/Math.tan((60*Math.PI)/360);
      camera.position.set(dist, dist*0.5, dist);
      camera.near = Math.max(0.01, nd*0.001);
      camera.far = dist*10;
      camera.updateProjectionMatrix();
    }

    const AR_MATERIAL = 'basic';
    function cloneForAR(src){
      const root = src.clone(true);
      root.traverse(o=>{
        if (!o.isMesh || !o.material) return;
        o.castShadow = true;
        o.receiveShadow = false;
        if (AR_MATERIAL === 'lambert'){
          const mat = new THREE.MeshLambertMaterial({
            color: (o.material.color && o.material.color.isColor) ? o.material.color.clone() : new THREE.Color(0xffffff),
            map: o.material.map || null,
            emissive: (o.material.emissive && o.material.emissive.isColor) ? o.material.emissive.clone() : new THREE.Color(0x101010),
            emissiveMap: o.material.emissiveMap || null,
            side: o.material.side
          });
          if (mat.map && 'colorSpace' in mat.map) mat.map.colorSpace = THREE.SRGBColorSpace;
          if (mat.emissiveMap && 'colorSpace' in mat.emissiveMap) mat.emissiveMap.colorSpace = THREE.SRGBColorSpace;
          o.material = mat;
        } else {
          const mat = new THREE.MeshBasicMaterial({
            color: (o.material.color && o.material.color.isColor) ? o.material.color.clone() : new THREE.Color(0xffffff),
            map: o.material.map || null,
            toneMapped:false
          });
          if (mat.map && 'colorSpace' in mat.map) mat.map.colorSpace = THREE.SRGBColorSpace;
          o.material = mat;
        }
      });
      return root;
    }

    function makeARShadowCatcher(size=2){
      const catcher = new THREE.Mesh(
        new THREE.PlaneGeometry(size, size),
        new THREE.ShadowMaterial({ opacity: 0.35 })
      );
      catcher.rotation.x = -Math.PI/2;
      catcher.receiveShadow = true;
      catcher.position.y = -0.001;
      return catcher;
    }

    function startFallbackViewer(){
      if (camera) return;
      camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 1000);
      camera.position.set(0.8,0.6,1.2);
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.08;
      controls.minDistance = 0.2; controls.maxDistance = 5; controls.maxPolarAngle = Math.PI*0.49;
      if (srcModel) addDesktopModel();
      (function loop(){
        requestAnimationFrame(loop);
        controls.update();
        renderer.render(scene,camera);
      })();
    }

    // --- Always use fallback on iOS (WebXR is experimental) ---
    startFallbackViewer();

    // --- Resize ---
    addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      if (camera){ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); }
    });
  </script>
</body>
</html>
